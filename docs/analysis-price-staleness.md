# Анализ: Откуда возникла неверная цена в сигналах

**Дата**: 2025-12-02  
**Проблема**: Ордера отклонялись Bybit с ошибкой "price is invalid (code: 110003)" из-за того, что лимитная цена была слишком далека от текущей рыночной цены.

## Цепочка передачи данных о цене

### 1. Источник данных: Bybit WebSocket → ws-gateway

**Поток данных:**
```
Bybit WebSocket → ws-gateway → RabbitMQ (ws-gateway.ticker) → model-service
```

**Данные приходят корректно:**
- ws-gateway получает тикеры через WebSocket от Bybit
- В логах видно актуальные цены: `88682.9`, `89038.2` (в районе 88k-89k)
- Данные публикуются в RabbitMQ очередь `ws-gateway.ticker`
- Время получения: регулярно, каждые ~200-500ms

**Пример из логов:**
```
ws-gateway: tickers.BTCUSDT lastPrice: '88682.9' (2025-12-02T19:14:13)
ws-gateway: tickers.BTCUSDT lastPrice: '89038.2' (2025-12-02T19:17:09)
```

### 2. Кеширование в model-service

**Компонент:** `MarketDataCache` в `market_data_consumer.py`

**Как работает:**
- model-service потребляет тикеры из RabbitMQ очереди `ws-gateway.ticker`
- Обновляет in-memory кеш через `cache.update_ticker(symbol, price, volume_24h)`
- Кеш хранит последние значения: `{price, spread, volume_24h, volatility, last_updated}`
- При запросе данных проверяет наличие всех required полей

**Проблема кеша:**
- Кеш обновляется только при получении новых тикеров из RabbitMQ
- Если тикеры не приходят или приходят редко, цена в кеше может устареть
- Нет проверки на "свежесть" данных (age check)
- Нет механизма обновления данных по таймеру

### 3. Создание сигнала в model-service

**Когда берется цена:**
1. `intelligent_signal_generator.py` вызывает `model_inference.get_market_data_snapshot(asset)`
2. `get_market_data_snapshot()` берет данные из `market_data_cache`
3. Создается `MarketDataSnapshot` с ценой из кеша
4. Сигнал создается с `market_data_snapshot.price` = цена на момент создания сигнала

**Пример из БД:**
```sql
signal_id: 443a0b06-ce29-4cfa-9037-223dd8d45cff
snapshot_price: 89038.2
created_at: 2025-12-02 18:55:44
```

**Цена 89038.2 была актуальной в момент создания сигнала!**

### 4. Обработка сигнала в order-manager

**Что происходит:**
1. order-manager получает сигнал из RabbitMQ
2. `order_type_selector.py` использует `snapshot_price` из сигнала для расчета лимитной цены
3. До исправления: использовалась только `snapshot_price` без проверки актуальности
4. После исправления: получает актуальную цену через Bybit API и сравнивает

**Проблема:**
- Между созданием сигнала (18:55:44) и обработкой (19:09:52) прошло ~14 минут
- За это время цена изменилась с ~89038 до ~88682 (изменение ~0.4%)
- Но из-за расчета лимитной цены с offset'ом, итоговая цена могла быть слишком далека

## Корневые причины проблемы

### Причина 1: Устаревание данных между созданием и обработкой сигнала

**Сценарий:**
1. Сигнал создается с актуальной ценой 89038.2 (18:55:44)
2. Сигнал публикуется в RabbitMQ
3. order-manager обрабатывает сигнал позже (19:09:52) - задержка ~14 минут
4. К этому времени рыночная цена уже изменилась до ~88682

**Решение:** ✅ Реализовано в варианте 3 - получение актуальной цены перед расчетом лимитной цены

### Причина 2: Отсутствие валидации отклонения цены

**Сценарий:**
1. Лимитная цена рассчитывается на основе устаревшего snapshot_price
2. Даже с правильным offset'ом, цена может быть слишком далека от текущего рынка
3. Bybit отклоняет ордер по `price_limit_ratio` правилам

**Решение:** ✅ Реализовано - валидация по `price_limit_ratio` перед отправкой в Bybit

### Причина 3: Нет проверки актуальности данных в кеше

**Потенциальная проблема:**
- Если тикеры перестали приходить (проблема с WebSocket/RabbitMQ)
- Кеш может содержать очень старые данные
- При создании сигнала используется устаревшая цена

**Текущее состояние:**
- Кеш обновляется только при получении новых тикеров
- Нет механизма проверки "свежести" данных (max age)
- Если данных нет в кеше - сигнал не создается (возвращается None)

## Выводы

### Что работает корректно:
1. ✅ ws-gateway получает актуальные данные от Bybit
2. ✅ Данные публикуются в RabbitMQ
3. ✅ model-service кеширует данные
4. ✅ Сигналы создаются с актуальными данными на момент создания

### Что может быть проблемой:
1. ⚠️ Задержка между созданием сигнала и обработкой (может быть несколько минут)
2. ⚠️ Нет проверки "свежести" данных в кеше (max age)
3. ⚠️ Нет механизма обновления данных по таймеру в кеше

### Что уже исправлено:
1. ✅ Получение актуальной рыночной цены перед расчетом лимитной цены
2. ✅ Валидация отклонения цены по `price_limit_ratio`
3. ✅ Автоматическая корректировка цены, если она слишком далека от рынка

## Рекомендации для улучшения

### 1. Добавить проверку "свежести" данных в кеше
```python
def get_market_data(self, symbol: str, max_age_seconds: int = 60) -> Optional[Dict[str, Any]]:
    data = self._cache.get(symbol, {})
    if not data:
        return None
    
    last_updated = data.get("last_updated")
    if last_updated:
        age = (datetime.utcnow() - last_updated).total_seconds()
        if age > max_age_seconds:
            logger.warning("Market data stale", symbol=symbol, age_seconds=age)
            return None  # или обновить через API
```

### 2. Мониторинг задержек в обработке сигналов
- Логировать время между созданием сигнала и обработкой
- Алерты если задержка > 5 минут

### 3. Проверка актуальности snapshot_price при обработке
- Если snapshot_price устарел (например, > 5 минут), получать актуальную цену
- Уже реализовано частично в варианте 3

