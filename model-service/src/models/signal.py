"""
Trading Signal data model.

Represents a high-level trading decision generated by the model or warm-up heuristics.
"""

from datetime import datetime
from typing import Optional, Dict, Any
from uuid import uuid4
from pydantic import BaseModel, Field, field_validator


class MarketDataSnapshot(BaseModel):
    """Market data snapshot at signal generation time."""

    price: float = Field(..., description="Current market price", gt=0)
    spread: float = Field(..., description="Bid-ask spread", ge=0)
    volume_24h: float = Field(..., description="24-hour trading volume", ge=0)
    volatility: float = Field(..., description="Current volatility measure", ge=0)
    orderbook_depth: Optional[Dict[str, float]] = Field(
        default=None, description="Order book depth (bid_depth, ask_depth)"
    )
    technical_indicators: Optional[Dict[str, float]] = Field(
        default=None, description="Technical indicators (RSI, MACD, etc.)"
    )


class TradingSignal(BaseModel):
    """
    Trading signal data model.

    Represents a high-level trading decision containing signal type, asset,
    amount, confidence, timestamp, and strategy identifier.
    """

    signal_id: str = Field(default_factory=lambda: str(uuid4()), description="Unique signal identifier")
    signal_type: str = Field(..., description="Trading signal type: 'buy' or 'sell'")
    asset: str = Field(..., description="Asset identifier (trading pair, e.g., 'BTCUSDT')")
    amount: float = Field(..., description="Amount in quote currency (USDT)", gt=0)
    confidence: float = Field(..., description="Confidence score (0-1)", ge=0, le=1)
    timestamp: datetime = Field(default_factory=datetime.utcnow, description="Signal generation timestamp")
    strategy_id: str = Field(..., description="Trading strategy identifier")
    model_version: Optional[str] = Field(default=None, description="Model version used (NULL for warm-up mode)")
    is_warmup: bool = Field(default=False, description="Whether signal generated in warm-up mode")
    market_data_snapshot: MarketDataSnapshot = Field(
        ..., description="Market data at signal generation time (REQUIRED for training)"
    )
    metadata: Optional[Dict[str, Any]] = Field(
        default=None, description="Additional signal metadata (reasoning, risk_score, etc.)"
    )
    trace_id: Optional[str] = Field(default=None, description="Trace ID for request flow tracking")

    @field_validator("signal_type")
    @classmethod
    def validate_signal_type(cls, v: str) -> str:
        """Validate signal type is 'buy' or 'sell'."""
        if v.lower() not in ("buy", "sell"):
            raise ValueError("signal_type must be 'buy' or 'sell'")
        return v.lower()

    @field_validator("asset")
    @classmethod
    def validate_asset(cls, v: str) -> str:
        """Validate asset is a valid trading pair format."""
        if not v or len(v) < 3:
            raise ValueError("asset must be a valid trading pair (e.g., 'BTCUSDT')")
        return v.upper()

    @field_validator("timestamp")
    @classmethod
    def validate_timestamp(cls, v: datetime) -> datetime:
        """Validate timestamp is not in the future."""
        if v > datetime.utcnow():
            raise ValueError("timestamp cannot be in the future")
        return v

    def to_dict(self) -> Dict[str, Any]:
        """
        Convert signal to dictionary for JSON serialization.

        Returns:
            Dictionary representation of the signal
        """
        return {
            "signal_id": self.signal_id,
            "signal_type": self.signal_type,
            "asset": self.asset,
            "amount": self.amount,
            "confidence": self.confidence,
            "timestamp": self.timestamp.isoformat() + "Z",
            "strategy_id": self.strategy_id,
            "model_version": self.model_version,
            "is_warmup": self.is_warmup,
            "market_data_snapshot": {
                "price": self.market_data_snapshot.price,
                "spread": self.market_data_snapshot.spread,
                "volume_24h": self.market_data_snapshot.volume_24h,
                "volatility": self.market_data_snapshot.volatility,
                "orderbook_depth": self.market_data_snapshot.orderbook_depth,
                "technical_indicators": self.market_data_snapshot.technical_indicators,
            },
            "metadata": self.metadata,
            "trace_id": self.trace_id,
        }

