# Feature Specification: Grafana Monitoring Dashboard

**Feature Branch**: `001-grafana-monitoring`  
**Created**: 2025-11-28  
**Status**: Draft  
**Input**: User description: "Задача - добавить визуальный мониторинг состояния проекта с помощью Grafana. Реализовать в отдельном контейнере. Предполагается, что Grafana будет в первую очередь брать данные из существующих БД, из REST API и из очередей RabbitMQ. Доступ к UI Grafana должен быть из внешнего мира, прикрыт авторизацией (способ авторизации - на выбор). Grafana Фаза 1: список недавних торговых сигналов от модели, список недавних ордеров с информацией как каждый из них был закрыт, состояние и статистика модели, базовые метрики качества, большие лаги в очередях rabbitmq (для диагностики все ли очереди разбираются вовремя), health-статус в целом и с разбивкой по сервисам, перечень или статистика ошибок (по возможности)."

## Clarifications

### Session 2025-11-28

- Q: How should Grafana UI authentication credentials be managed? → A: Single admin user with username/password stored in `.env` file (default: admin/admin, configurable)
- Q: Which RabbitMQ queues should be monitored for lags? → A: All queues in RabbitMQ (including system queues like `amq.*`)
- Q: How should Grafana access the PostgreSQL database? → A: Read-only PostgreSQL user with credentials stored in `.env` file (separate from service credentials)
- Q: How should Grafana access RabbitMQ for queue monitoring? → A: RabbitMQ Management API (HTTP API on management plugin port) with credentials stored in `.env` file
- Q: How should Grafana authenticate when accessing REST API endpoints (health checks, model statistics, WebSocket connection state)? → A: Use existing service API keys from `.env` file where required (e.g., `WS_GATEWAY_API_KEY` for ws-gateway endpoints that require authentication)

## User Scenarios & Testing *(mandatory)*

### User Story 1 - View Recent Trading Signals (Priority: P1)

Traders and operators can view a list of recent trading signals generated by the model, including signal details such as asset, side, price, confidence, and timestamp, to monitor model activity and decision-making in real-time.

**Why this priority**: This is the primary way operators verify that the trading model is actively generating signals and making decisions. Without visibility into recent signals, operators cannot confirm the system is functioning or diagnose issues when trading stops or behaves unexpectedly.

**Independent Test**: Can be fully tested by accessing the Grafana dashboard and verifying that recent trading signals are displayed in a table or list format with all required fields (signal ID, asset, side, price, confidence, timestamp, strategy ID). The dashboard delivers immediate visibility into model activity without requiring any system modifications.

**Acceptance Scenarios**:

1. **Given** the system has generated trading signals, **When** a user accesses the Grafana dashboard, **Then** they see a list of recent trading signals (last 100 signals, prioritizing quantity) with all key attributes displayed
2. **Given** trading signals are being generated continuously, **When** a user views the signals dashboard, **Then** the list updates automatically or can be refreshed to show the most recent signals
3. **Given** multiple strategies are active, **When** a user views the signals dashboard, **Then** they can filter or identify signals by strategy ID
4. **Given** a user wants to investigate a specific signal, **When** they view the signals dashboard, **Then** they can see enough detail (signal ID, timestamp, asset, side, price, confidence) to trace the signal through the system

---

### User Story 2 - Monitor Order Execution Status (Priority: P1)

Traders and operators can view a list of recent orders with information about how each order was closed (filled, cancelled, rejected, etc.), including execution details such as execution price, quantity, fees, and performance metrics, to track trading outcomes and identify execution issues.

**Why this priority**: This provides critical visibility into whether signals are being successfully executed and how orders are performing. Operators need to know if orders are being filled at expected prices, if there are high cancellation rates, or if execution quality is degrading.

**Independent Test**: Can be fully tested by accessing the Grafana dashboard and verifying that recent orders are displayed with execution status, closure information, and performance metrics. The dashboard delivers immediate visibility into order execution outcomes without requiring any system modifications.

**Acceptance Scenarios**:

1. **Given** orders have been executed in the system, **When** a user accesses the Grafana dashboard, **Then** they see a list of recent orders (last 100 orders, prioritizing quantity) with execution status and closure information
2. **Given** an order has been filled, **When** a user views the order details, **Then** they can see execution price, quantity, fees, and realized PnL if available
3. **Given** an order has been cancelled or rejected, **When** a user views the order details, **Then** they can see the closure reason or status
4. **Given** orders are being executed continuously, **When** a user views the orders dashboard, **Then** the list updates automatically or can be refreshed to show the most recent orders

---

### User Story 3 - Monitor Model State and Quality Metrics (Priority: P2)

Traders and operators can view the current state of the trading model, including active model version, training status, and basic quality metrics (e.g., win rate, accuracy, total PnL), to assess model performance and determine if retraining or intervention is needed.

**Why this priority**: This enables operators to monitor model health and performance over time. Understanding model quality metrics helps identify when models are degrading and need retraining, or when model performance is improving.

**Independent Test**: Can be fully tested by accessing the Grafana dashboard and verifying that model state information and quality metrics are displayed. The dashboard delivers visibility into model health and performance trends without requiring any system modifications.

**Acceptance Scenarios**:

1. **Given** the model service is running, **When** a user accesses the Grafana dashboard, **Then** they see the current model state (active model version, training status, warm-up mode status)
2. **Given** quality metrics are available, **When** a user views the model statistics dashboard, **Then** they see basic quality metrics such as win rate, total orders, successful orders, and total PnL
3. **Given** quality metrics are tracked over time, **When** a user views the model statistics dashboard, **Then** they can see trends or historical values for quality metrics
4. **Given** multiple strategies are active, **When** a user views the model statistics dashboard, **Then** they can see metrics broken down by strategy if available

---

### User Story 4 - Detect RabbitMQ Queue Lags (Priority: P2)

Operators can monitor RabbitMQ queue lengths and message processing rates to detect when queues are backing up, indicating that consumers are not processing messages fast enough or have stopped consuming, which could cause system delays or data loss.

**Why this priority**: Queue lags are critical indicators of system health. If queues are backing up, it means events are not being processed in a timely manner, which can lead to stale signals, delayed order execution, or missed trading opportunities. Early detection allows operators to intervene before issues escalate.

**Independent Test**: Can be fully tested by accessing the Grafana dashboard and verifying that RabbitMQ queue metrics (queue length, message rate, consumer count) are displayed for all relevant queues. The dashboard delivers immediate visibility into queue health without requiring any system modifications.

**Acceptance Scenarios**:

1. **Given** RabbitMQ is running with active queues, **When** a user accesses the Grafana dashboard, **Then** they see queue length and message processing rates for all queues in RabbitMQ (including system queues)
2. **Given** a queue is backing up (high message count, low consumption rate), **When** a user views the queue monitoring dashboard, **Then** they can identify which queue has the lag and see how severe it is
3. **Given** queue metrics are tracked over time, **When** a user views the queue monitoring dashboard, **Then** they can see trends showing when queues started backing up
4. **Given** multiple queues exist, **When** a user views the queue monitoring dashboard, **Then** they can see all queues in a single view to compare their health

---

### User Story 5 - Monitor System Health Status (Priority: P1)

Operators can view the overall health status of the trading system and health status broken down by individual services, along with error statistics or lists, to quickly identify which services are healthy and which are experiencing issues.

**Why this priority**: This is the foundation of operational monitoring. Operators need to know at a glance whether the entire system is functioning correctly and which specific services are causing problems. Without this visibility, diagnosing issues requires manual investigation of multiple services.

**Independent Test**: Can be fully tested by accessing the Grafana dashboard and verifying that health status is displayed for all services and the overall system. The dashboard delivers immediate visibility into system health without requiring any system modifications.

**Acceptance Scenarios**:

1. **Given** services are running with health check endpoints, **When** a user accesses the Grafana dashboard, **Then** they see the overall system health status (healthy/unhealthy) and individual service health status
2. **Given** a service becomes unhealthy, **When** a user views the health status dashboard, **Then** they can immediately identify which service is unhealthy
3. **Given** services report error information, **When** a user views the health status dashboard, **Then** they can see error statistics or lists for services that are experiencing issues
4. **Given** health status is monitored continuously, **When** a user views the health status dashboard, **Then** the status updates automatically or can be refreshed to show current state

---

### User Story 6 - Monitor WebSocket Connection to Bybit Exchange (Priority: P2)

Operators can monitor the WebSocket connection status and metrics for the connection to Bybit exchange, including connection state, reconnection attempts, heartbeat status, and active subscriptions, to ensure data flow from the exchange is uninterrupted.

**Why this priority**: The WebSocket connection to Bybit is critical for receiving real-time market data and order updates. If the connection is down or frequently reconnecting, the trading system may be operating on stale data or missing important market events. Monitoring connection health helps operators identify connectivity issues before they impact trading decisions.

**Independent Test**: Can be fully tested by accessing the Grafana dashboard and verifying that WebSocket connection metrics are displayed. The dashboard delivers immediate visibility into connection health without requiring any system modifications.

**Acceptance Scenarios**:

1. **Given** the ws-gateway service is running, **When** a user accesses the Grafana dashboard, **Then** they see the current WebSocket connection status (connected/disconnected/connecting/reconnecting) for the Bybit connection
2. **Given** the WebSocket connection has reconnected, **When** a user views the connection metrics dashboard, **Then** they can see the reconnection count and last error message if any
3. **Given** the WebSocket connection is active, **When** a user views the connection metrics dashboard, **Then** they can see connection duration (time since connected_at), last heartbeat timestamp, and number of active subscriptions
4. **Given** the WebSocket connection experiences issues, **When** a user views the connection metrics dashboard, **Then** they can see connection state transitions over time to identify patterns of disconnections

---

### User Story 7 - View Recent Key Events History (Priority: P2)

Operators can view a chronological history of recent key system events, including trading signals received, orders created/executed/closed, model training/retraining events, WebSocket subscription changes, and other significant system state changes, to understand system activity and trace the sequence of events leading to current system state.

**Why this priority**: This provides a unified timeline view of system activity, making it easier to correlate events across different components (model, orders, WebSocket subscriptions). Operators can quickly understand what happened in the system recently and trace issues back to specific events. This complements the individual dashboards by providing a holistic view.

**Independent Test**: Can be fully tested by accessing the Grafana dashboard and verifying that recent key events are displayed in chronological order with event type, timestamp, and relevant details. The dashboard delivers immediate visibility into system activity without requiring any system modifications.

**Acceptance Scenarios**:

1. **Given** key events have occurred in the system, **When** a user accesses the Grafana dashboard, **Then** they see a chronological list of recent events (last 200 events, prioritizing quantity) including: trading signals received, orders created/executed/closed, model training/retraining started/completed, WebSocket subscription created/cancelled, WebSocket connection state changes
2. **Given** events are occurring continuously, **When** a user views the events history dashboard, **Then** the list updates automatically or can be refreshed to show the most recent events
3. **Given** multiple event types are displayed, **When** a user views the events history, **Then** they can filter events by type (signal, order, model training, subscription, connection) or by service
4. **Given** a user wants to investigate a specific event, **When** they view the events history, **Then** they can see enough detail (event type, timestamp, event ID, related entity IDs, status) to trace the event through the system
5. **Given** model training or retraining events occur, **When** a user views the events history, **Then** they can see training start/completion events with model version information
6. **Given** WebSocket subscription changes occur, **When** a user views the events history, **Then** they can see subscription created/cancelled events with channel type, symbol, and requesting service information

---

### Edge Cases

- What happens when a data source (database, REST API, RabbitMQ) is temporarily unavailable? The dashboard should handle connection failures gracefully, show connection status, and continue displaying cached data if available
- How does the dashboard handle services that don't have health check endpoints? The dashboard should indicate "unknown" or "not available" status rather than failing
- What happens when there are no recent signals or orders to display? The dashboard should show an empty state message rather than an error
- What happens when there are no recent events to display in the event history? The dashboard should show an empty state message rather than an error
- How does the dashboard handle events from different time zones or clock synchronization issues? Events should be displayed in a consistent timezone (UTC recommended) with clear timestamp formatting
- How does the dashboard handle very high message rates or large datasets? The dashboard should display aggregated or sampled data to maintain performance
- What happens when authentication fails? Users should see a clear authentication error message and be prompted to re-authenticate
- What happens when the WebSocket connection state is not available? The dashboard should indicate "unknown" or "not available" status rather than failing
- How does the dashboard handle WebSocket connection state when there are multiple connections (public and private)? The dashboard should display metrics for all active connections or indicate which connection type is being monitored

## Requirements *(mandatory)*

### Functional Requirements

- **FR-001**: System MUST provide a Grafana dashboard accessible from external networks with authentication protection
- **FR-002**: System MUST display a list of recent trading signals (last 100 signals, prioritizing quantity over time range) with key attributes: signal ID, asset, side, price, confidence, timestamp, strategy ID
- **FR-003**: System MUST display a list of recent orders (last 100 orders, prioritizing quantity over time range) with execution status and closure information: order ID, signal ID, asset, side, execution price, execution quantity, execution fees, executed timestamp, closure status (filled/cancelled/rejected)
- **FR-004**: System MUST display model state information: active model version, training status, warm-up mode status, current strategy IDs
- **FR-005**: System MUST display basic model quality metrics: win rate, total orders count, successful orders count, total PnL. Total PnL is considered available when `execution_events.performance` JSONB field contains `realized_pnl` key with a numeric value
- **FR-006**: System MUST monitor RabbitMQ queue lengths and message processing rates for all queues in RabbitMQ (including system queues like `amq.*`) to detect lags
- **FR-007**: System MUST display overall system health status (healthy/unhealthy) aggregated from all services
- **FR-008**: System MUST display individual service health status for each monitored service (ws-gateway, model-service, order-manager, postgres, rabbitmq)
- **FR-009**: System MUST display error statistics or error lists for services when available (e.g., error counts, recent error messages)
- **FR-010**: System MUST display WebSocket connection metrics to Bybit exchange: connection status (connected/disconnected/connecting/reconnecting), environment (mainnet/testnet), connection duration, last heartbeat timestamp, reconnection count, last error message, and active subscriptions count
- **FR-011**: System MUST connect to PostgreSQL database to query trading signals, orders, and execution events using a read-only database user. Database credentials (host, port, database name, username, password) MUST be configurable via `.env` file (separate from service database credentials)
- **FR-012**: System MUST connect to REST API endpoints to retrieve health status, model statistics, and WebSocket connection state. Authentication MUST use existing service API keys from `.env` file where required (e.g., `WS_GATEWAY_API_KEY` for ws-gateway endpoints that require authentication)
- **FR-013**: System MUST connect to RabbitMQ Management API (HTTP API on management plugin port) to monitor queue metrics (queue length, message rate, consumer count). RabbitMQ Management API credentials (host, port, username, password) MUST be configurable via `.env` file
- **FR-014**: System MUST implement authentication for Grafana UI access using basic authentication (username/password) with a single admin user. Credentials (username and password) MUST be configurable via `.env` file with default values (admin/admin) for initial setup
- **FR-015**: System MUST run Grafana in a separate Docker container managed via docker-compose.yml
- **FR-016**: System MUST handle data source connection failures gracefully without crashing the dashboard
- **FR-017**: System MUST update dashboard data automatically or provide manual refresh capability
- **FR-018**: System MUST prioritize displaying data from existing sources without requiring major system modifications
- **FR-019**: System MUST display a chronological history of recent key system events (last 200 events, prioritizing quantity) including: trading signals received (signal ID, asset, side, price, confidence, timestamp, strategy ID), orders created/executed/closed (order ID, signal ID, asset, side, status, timestamp), model training/retraining events (model version ID, training status, start/completion timestamp), WebSocket subscription created/cancelled (subscription ID, channel type, symbol, requesting service, timestamp), and WebSocket connection state changes (connection status, timestamp)
- **FR-020**: System MUST allow filtering of event history by event type (signal, order, model training, subscription, connection) and by service (model-service, order-manager, ws-gateway)
- **FR-021**: System MUST update event history automatically or provide manual refresh capability

### Key Entities *(include if feature involves data)*

- **Trading Signal**: Represents a trading decision generated by the model, including signal ID, asset, side (buy/sell), price, confidence score, timestamp, strategy ID, model version, is_warmup flag, and market_data_snapshot. Source: PostgreSQL `trading_signals` table (model-service persists all trading signals to database)
- **Order Execution Event**: Represents an executed order with closure information, including order ID, signal ID, strategy ID, asset, side, execution price, execution quantity, execution fees, executed timestamp, and performance metrics. Source: PostgreSQL `execution_events` table
- **Model State**: Represents current model status including active model version ID, training status (idle/training), warm-up mode status, and active strategy IDs. Source: Model service REST API or database
- **Model Quality Metrics**: Represents performance indicators including win rate, total orders count, successful orders count, total PnL. Source: Calculated from `execution_events` table or model service REST API
- **Queue Metrics**: Represents RabbitMQ queue health including queue name, message count (queue length), message publishing rate, message consumption rate, consumer count. Source: RabbitMQ management API. All queues in RabbitMQ are monitored, including system queues
- **Service Health Status**: Represents health state of a service including service name, overall status (healthy/unhealthy), component statuses (database, queue, websocket), error information. Source: Service health check REST API endpoints
- **WebSocket Connection State**: Represents WebSocket connection to Bybit exchange including connection ID, environment (mainnet/testnet), status (connected/disconnected/connecting/reconnecting), connected timestamp, last heartbeat timestamp, reconnection count, last error message, and active subscriptions count. Source: ws-gateway service health endpoint (`/health`) or WebSocket state API
- **Event History**: Represents a chronological log of key system events including event type (trading_signal_received, order_created, order_executed, order_closed, model_training_started, model_training_completed, model_retrained, subscription_created, subscription_cancelled, websocket_connected, websocket_disconnected, websocket_reconnected), event timestamp, event ID, related entity IDs (signal ID, order ID, model version ID, subscription ID), event details (asset, side, price, status, channel type, symbol, requesting service), and service name. Source: Aggregated from multiple sources: trading signals from PostgreSQL `trading_signals` table, order events from PostgreSQL `execution_events` table, model training events from model service REST API or database, subscription events from ws-gateway service REST API or database, connection events from ws-gateway service health endpoint

## Success Criteria *(mandatory)*

### Measurable Outcomes

- **SC-001**: Operators can view recent trading signals (last 100 signals, prioritizing quantity) within 3 seconds of accessing the dashboard
- **SC-002**: Operators can view recent orders with execution status (last 100 orders, prioritizing quantity) within 3 seconds of accessing the dashboard
- **SC-003**: Operators can identify which RabbitMQ queues have lags (queue length > 1000 messages or consumption rate < 10% of publishing rate) within 5 seconds of accessing the dashboard
- **SC-004**: Operators can determine overall system health status and identify unhealthy services within 2 seconds of accessing the dashboard
- **SC-005**: Operators can view WebSocket connection status and key metrics (connection state, reconnection count, last heartbeat) within 2 seconds of accessing the dashboard
- **SC-006**: Dashboard displays model state and quality metrics for all active strategies without requiring manual data collection
- **SC-007**: Dashboard remains accessible and functional even when one data source (database, REST API, or RabbitMQ) is temporarily unavailable
- **SC-008**: Authentication protects dashboard access, preventing unauthorized users from viewing trading system data
- **SC-009**: Dashboard updates data automatically at least once per minute or provides manual refresh that completes within 5 seconds
- **SC-010**: Operators can view recent key events history (last 200 events, prioritizing quantity) within 3 seconds of accessing the dashboard
- **SC-011**: Operators can filter event history by event type or service within 2 seconds of applying filters

## Assumptions

- PostgreSQL database contains `execution_events` table with order execution information
- Trading signals are available via RabbitMQ queue `model-service.trading_signals` or can be queried from database if persisted
- Services (ws-gateway, model-service, order-manager) expose `/health` REST API endpoints that return health status
- ws-gateway service `/health` endpoint returns WebSocket connection state including status, reconnection count, last heartbeat, and active subscriptions
- Model service exposes REST API endpoints for model state and statistics (or this information can be derived from database)
- Model training/retraining events are available via model service REST API or can be derived from database (model_versions table with training status and timestamps)
- WebSocket subscription events (created/cancelled) are available via ws-gateway service REST API (`/api/v1/subscriptions`) or can be derived from database (subscriptions table with created_at, updated_at, is_active status)
- Event history can be aggregated from multiple data sources (database tables, REST API endpoints) without requiring a dedicated event log table
- RabbitMQ management API is accessible for queue monitoring (standard RabbitMQ management plugin). Grafana connects to the Management API using credentials configured via `.env` file
- Grafana can connect to PostgreSQL as a data source using a read-only database user with credentials configured via `.env` file
- Grafana can query REST APIs using HTTP data source or similar plugin. Authentication uses existing service API keys from `.env` file where endpoints require authentication
- Grafana can monitor RabbitMQ queues using the RabbitMQ Management API data source or plugin with credentials configured via `.env` file
- No major modifications to existing services are required to provide monitoring data (data is available from existing sources)
- Basic authentication (username/password) is used for Grafana UI access with a single admin user. Credentials are configured via `.env` file (default: admin/admin), which is the standard default for monitoring dashboards

## Dependencies

- PostgreSQL database must be running and accessible with a read-only user account for Grafana (credentials configured via `.env` file)
- RabbitMQ must be running with management plugin enabled
- Services (ws-gateway, model-service, order-manager) must be running and exposing health check endpoints
- Docker and Docker Compose V2 must be available for container management
- Network connectivity between Grafana container and data sources (database, RabbitMQ, service APIs)

## Out of Scope

- Phase 2 features (detailed WebSocket message rate and latency metrics, detailed model metrics, PnL dashboards, analytical trader boards, DevOps metrics, log aggregation) - these will be addressed in future phases
- Modifying existing services to add new monitoring endpoints (Phase 1 focuses on existing data sources)
- Real-time alerting and notifications (monitoring only, alerts can be added later)
- Historical data analysis beyond recent signals and orders (last 100 or 24 hours)
- Custom Grafana plugin development (using existing plugins and data sources)
